=begin
#JumpCloud APIs

# JumpCloud's V1 API. This set of endpoints allows JumpCloud customers to manage commands, systems, & system users.

OpenAPI spec version: 1.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.1

=end

require 'date'

module JCAPIv1

  class OrganizationsettingsPasswordPolicy
    attr_accessor :allow_username_substring

    attr_accessor :days_after_expiration_to_self_recover

    attr_accessor :days_before_expiration_to_force_reset

    attr_accessor :enable_days_after_expiration_to_self_recover

    attr_accessor :enable_days_before_expiration_to_force_reset

    attr_accessor :enable_lockout_time_in_seconds

    attr_accessor :enable_max_history

    attr_accessor :enable_max_login_attempts

    attr_accessor :enable_min_change_period_in_days

    attr_accessor :enable_min_length

    attr_accessor :enable_password_expiration_in_days

    attr_accessor :lockout_time_in_seconds

    attr_accessor :max_history

    attr_accessor :max_login_attempts

    attr_accessor :min_change_period_in_days

    attr_accessor :min_length

    attr_accessor :needs_lowercase

    attr_accessor :needs_numeric

    attr_accessor :needs_symbolic

    attr_accessor :needs_uppercase

    attr_accessor :password_expiration_in_days


    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'allow_username_substring' => :'allowUsernameSubstring',
        :'days_after_expiration_to_self_recover' => :'daysAfterExpirationToSelfRecover',
        :'days_before_expiration_to_force_reset' => :'daysBeforeExpirationToForceReset',
        :'enable_days_after_expiration_to_self_recover' => :'enableDaysAfterExpirationToSelfRecover',
        :'enable_days_before_expiration_to_force_reset' => :'enableDaysBeforeExpirationToForceReset',
        :'enable_lockout_time_in_seconds' => :'enableLockoutTimeInSeconds',
        :'enable_max_history' => :'enableMaxHistory',
        :'enable_max_login_attempts' => :'enableMaxLoginAttempts',
        :'enable_min_change_period_in_days' => :'enableMinChangePeriodInDays',
        :'enable_min_length' => :'enableMinLength',
        :'enable_password_expiration_in_days' => :'enablePasswordExpirationInDays',
        :'lockout_time_in_seconds' => :'lockoutTimeInSeconds',
        :'max_history' => :'maxHistory',
        :'max_login_attempts' => :'maxLoginAttempts',
        :'min_change_period_in_days' => :'minChangePeriodInDays',
        :'min_length' => :'minLength',
        :'needs_lowercase' => :'needsLowercase',
        :'needs_numeric' => :'needsNumeric',
        :'needs_symbolic' => :'needsSymbolic',
        :'needs_uppercase' => :'needsUppercase',
        :'password_expiration_in_days' => :'passwordExpirationInDays'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'allow_username_substring' => :'BOOLEAN',
        :'days_after_expiration_to_self_recover' => :'Integer',
        :'days_before_expiration_to_force_reset' => :'Integer',
        :'enable_days_after_expiration_to_self_recover' => :'BOOLEAN',
        :'enable_days_before_expiration_to_force_reset' => :'BOOLEAN',
        :'enable_lockout_time_in_seconds' => :'BOOLEAN',
        :'enable_max_history' => :'BOOLEAN',
        :'enable_max_login_attempts' => :'BOOLEAN',
        :'enable_min_change_period_in_days' => :'BOOLEAN',
        :'enable_min_length' => :'BOOLEAN',
        :'enable_password_expiration_in_days' => :'BOOLEAN',
        :'lockout_time_in_seconds' => :'Integer',
        :'max_history' => :'Integer',
        :'max_login_attempts' => :'Integer',
        :'min_change_period_in_days' => :'Integer',
        :'min_length' => :'Integer',
        :'needs_lowercase' => :'BOOLEAN',
        :'needs_numeric' => :'BOOLEAN',
        :'needs_symbolic' => :'BOOLEAN',
        :'needs_uppercase' => :'BOOLEAN',
        :'password_expiration_in_days' => :'Integer'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'allowUsernameSubstring')
        self.allow_username_substring = attributes[:'allowUsernameSubstring']
      end

      if attributes.has_key?(:'daysAfterExpirationToSelfRecover')
        self.days_after_expiration_to_self_recover = attributes[:'daysAfterExpirationToSelfRecover']
      end

      if attributes.has_key?(:'daysBeforeExpirationToForceReset')
        self.days_before_expiration_to_force_reset = attributes[:'daysBeforeExpirationToForceReset']
      end

      if attributes.has_key?(:'enableDaysAfterExpirationToSelfRecover')
        self.enable_days_after_expiration_to_self_recover = attributes[:'enableDaysAfterExpirationToSelfRecover']
      end

      if attributes.has_key?(:'enableDaysBeforeExpirationToForceReset')
        self.enable_days_before_expiration_to_force_reset = attributes[:'enableDaysBeforeExpirationToForceReset']
      end

      if attributes.has_key?(:'enableLockoutTimeInSeconds')
        self.enable_lockout_time_in_seconds = attributes[:'enableLockoutTimeInSeconds']
      end

      if attributes.has_key?(:'enableMaxHistory')
        self.enable_max_history = attributes[:'enableMaxHistory']
      end

      if attributes.has_key?(:'enableMaxLoginAttempts')
        self.enable_max_login_attempts = attributes[:'enableMaxLoginAttempts']
      end

      if attributes.has_key?(:'enableMinChangePeriodInDays')
        self.enable_min_change_period_in_days = attributes[:'enableMinChangePeriodInDays']
      end

      if attributes.has_key?(:'enableMinLength')
        self.enable_min_length = attributes[:'enableMinLength']
      end

      if attributes.has_key?(:'enablePasswordExpirationInDays')
        self.enable_password_expiration_in_days = attributes[:'enablePasswordExpirationInDays']
      end

      if attributes.has_key?(:'lockoutTimeInSeconds')
        self.lockout_time_in_seconds = attributes[:'lockoutTimeInSeconds']
      end

      if attributes.has_key?(:'maxHistory')
        self.max_history = attributes[:'maxHistory']
      end

      if attributes.has_key?(:'maxLoginAttempts')
        self.max_login_attempts = attributes[:'maxLoginAttempts']
      end

      if attributes.has_key?(:'minChangePeriodInDays')
        self.min_change_period_in_days = attributes[:'minChangePeriodInDays']
      end

      if attributes.has_key?(:'minLength')
        self.min_length = attributes[:'minLength']
      end

      if attributes.has_key?(:'needsLowercase')
        self.needs_lowercase = attributes[:'needsLowercase']
      end

      if attributes.has_key?(:'needsNumeric')
        self.needs_numeric = attributes[:'needsNumeric']
      end

      if attributes.has_key?(:'needsSymbolic')
        self.needs_symbolic = attributes[:'needsSymbolic']
      end

      if attributes.has_key?(:'needsUppercase')
        self.needs_uppercase = attributes[:'needsUppercase']
      end

      if attributes.has_key?(:'passwordExpirationInDays')
        self.password_expiration_in_days = attributes[:'passwordExpirationInDays']
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if !@days_after_expiration_to_self_recover.nil? && @days_after_expiration_to_self_recover < 1
        invalid_properties.push("invalid value for 'days_after_expiration_to_self_recover', must be greater than or equal to 1.")
      end

      if !@days_before_expiration_to_force_reset.nil? && @days_before_expiration_to_force_reset < 1
        invalid_properties.push("invalid value for 'days_before_expiration_to_force_reset', must be greater than or equal to 1.")
      end

      if !@max_history.nil? && @max_history > 10
        invalid_properties.push("invalid value for 'max_history', must be smaller than or equal to 10.")
      end

      if !@max_history.nil? && @max_history < 1
        invalid_properties.push("invalid value for 'max_history', must be greater than or equal to 1.")
      end

      if !@max_login_attempts.nil? && @max_login_attempts < 0
        invalid_properties.push("invalid value for 'max_login_attempts', must be greater than or equal to 0.")
      end

      if !@password_expiration_in_days.nil? && @password_expiration_in_days < 1
        invalid_properties.push("invalid value for 'password_expiration_in_days', must be greater than or equal to 1.")
      end

      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if !@days_after_expiration_to_self_recover.nil? && @days_after_expiration_to_self_recover < 1
      return false if !@days_before_expiration_to_force_reset.nil? && @days_before_expiration_to_force_reset < 1
      return false if !@max_history.nil? && @max_history > 10
      return false if !@max_history.nil? && @max_history < 1
      return false if !@max_login_attempts.nil? && @max_login_attempts < 0
      return false if !@password_expiration_in_days.nil? && @password_expiration_in_days < 1
      return true
    end

    # Custom attribute writer method with validation
    # @param [Object] days_after_expiration_to_self_recover Value to be assigned
    def days_after_expiration_to_self_recover=(days_after_expiration_to_self_recover)

      if !days_after_expiration_to_self_recover.nil? && days_after_expiration_to_self_recover < 1
        fail ArgumentError, "invalid value for 'days_after_expiration_to_self_recover', must be greater than or equal to 1."
      end

      @days_after_expiration_to_self_recover = days_after_expiration_to_self_recover
    end

    # Custom attribute writer method with validation
    # @param [Object] days_before_expiration_to_force_reset Value to be assigned
    def days_before_expiration_to_force_reset=(days_before_expiration_to_force_reset)

      if !days_before_expiration_to_force_reset.nil? && days_before_expiration_to_force_reset < 1
        fail ArgumentError, "invalid value for 'days_before_expiration_to_force_reset', must be greater than or equal to 1."
      end

      @days_before_expiration_to_force_reset = days_before_expiration_to_force_reset
    end

    # Custom attribute writer method with validation
    # @param [Object] max_history Value to be assigned
    def max_history=(max_history)

      if !max_history.nil? && max_history > 10
        fail ArgumentError, "invalid value for 'max_history', must be smaller than or equal to 10."
      end

      if !max_history.nil? && max_history < 1
        fail ArgumentError, "invalid value for 'max_history', must be greater than or equal to 1."
      end

      @max_history = max_history
    end

    # Custom attribute writer method with validation
    # @param [Object] max_login_attempts Value to be assigned
    def max_login_attempts=(max_login_attempts)

      if !max_login_attempts.nil? && max_login_attempts < 0
        fail ArgumentError, "invalid value for 'max_login_attempts', must be greater than or equal to 0."
      end

      @max_login_attempts = max_login_attempts
    end

    # Custom attribute writer method with validation
    # @param [Object] password_expiration_in_days Value to be assigned
    def password_expiration_in_days=(password_expiration_in_days)

      if !password_expiration_in_days.nil? && password_expiration_in_days < 1
        fail ArgumentError, "invalid value for 'password_expiration_in_days', must be greater than or equal to 1."
      end

      @password_expiration_in_days = password_expiration_in_days
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          allow_username_substring == o.allow_username_substring &&
          days_after_expiration_to_self_recover == o.days_after_expiration_to_self_recover &&
          days_before_expiration_to_force_reset == o.days_before_expiration_to_force_reset &&
          enable_days_after_expiration_to_self_recover == o.enable_days_after_expiration_to_self_recover &&
          enable_days_before_expiration_to_force_reset == o.enable_days_before_expiration_to_force_reset &&
          enable_lockout_time_in_seconds == o.enable_lockout_time_in_seconds &&
          enable_max_history == o.enable_max_history &&
          enable_max_login_attempts == o.enable_max_login_attempts &&
          enable_min_change_period_in_days == o.enable_min_change_period_in_days &&
          enable_min_length == o.enable_min_length &&
          enable_password_expiration_in_days == o.enable_password_expiration_in_days &&
          lockout_time_in_seconds == o.lockout_time_in_seconds &&
          max_history == o.max_history &&
          max_login_attempts == o.max_login_attempts &&
          min_change_period_in_days == o.min_change_period_in_days &&
          min_length == o.min_length &&
          needs_lowercase == o.needs_lowercase &&
          needs_numeric == o.needs_numeric &&
          needs_symbolic == o.needs_symbolic &&
          needs_uppercase == o.needs_uppercase &&
          password_expiration_in_days == o.password_expiration_in_days
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [allow_username_substring, days_after_expiration_to_self_recover, days_before_expiration_to_force_reset, enable_days_after_expiration_to_self_recover, enable_days_before_expiration_to_force_reset, enable_lockout_time_in_seconds, enable_max_history, enable_max_login_attempts, enable_min_change_period_in_days, enable_min_length, enable_password_expiration_in_days, lockout_time_in_seconds, max_history, max_login_attempts, min_change_period_in_days, min_length, needs_lowercase, needs_numeric, needs_symbolic, needs_uppercase, password_expiration_in_days].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = JCAPIv1.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
